'use strict'

const App = require('../../app')
const logger = require('../../lib/logger')('service:resource:template')

const ResourceTemplateModel = require('../../entity/resource/template').Entity;
const MonitorTemplateModel = require('../../entity/monitor/template').Entity;
const MonitorModel = require('../../entity/monitor').Entity;
const ResourceModel = require('../../entity/resource').Entity;

//const MonitorService = require('./monitor')

module.exports = {
  /**
   *
   * @author Facundo
   * @param {HostGroup} hostgroup
   * @param {Array Resource} resources
   * @param {Customer} customer
   * @param {User} user
   * @param {Function} done
   * @return {Promise}
   *
   */
  createTemplates (hostgroup, resources, customer, user) {
    if (!resources) {
      return done(null, [])
    }
    if (!Array.isArray(resources) || resources.length===0) {
      return done(null, [])
    }

    logger.log('processing %s resource monitors', resources.length);

    const resourcesData = []
    for (let resource of resources) {
      if (!resource || !resource.monitor) {
        const err = new Error('Invalid Monitor Data')
        err.statusCode = 400
        err.resource = resource
        throw err
      }

      const monitor = resource.monitor
      const config = Object.assign({}, monitor, monitor.config||{})
      const result = App.resourceMonitor.validateData(config)

      if (!result || result.errors) {
        const msg = 'Invalid monitor data'
        logger.error(msg)
        const err = new Error(msg)
        err.statusCode = 400
        err.data = config
        err.errors = result.errors
        throw err
      }

      const data = result.data
      data.customer = customer
      // DO NOT UN-COMMENT ! user property generates conflict with monitor.config.user property of monitor.type === file 
      //data.user = user
      data.hostgroup = hostgroup
      data.source_monitor_id = monitor.source_model_id
      data.source_resource_id = resource.source_model_id

      resourcesData.push(data)
    }

    /* create templates from input */
    const templates = []
    if (resourcesData.length > 0) {
      for (let data of resourcesData) {
        templates.push(createResourceTemplate(data))
      }
    }
    return Promise.all(templates)
  }
}

/**
 * create resource and monito from input
 * @author Facundo
 * @param {Object} input
 */
const createResourceTemplate = async (input) => {
  const data = {
    customer: input.customer._id,
    customer_id: input.customer._id,
    customer_name: input.customer.name,
    type: input.type,
    name: input.name,
    description: input.description,
  }

  // provisional model. will not persist into the database
  let monitor = await App.resourceMonitor.create( input.type, Object.assign({}, input, data) )
  let monitor_data = monitor.toObject()
  monitor_data.source_model_id = input.source_monitor_id
  delete monitor_data.host_id // not needed. just in case...
  delete monitor_data._id // must be autogenerated

  logger.log ('creating monitor template')
  // create both and link them together

  let monitorTemplate = new MonitorTemplateModel(monitor_data)
  const resourceTemplate = new ResourceTemplateModel(data)

  resourceTemplate._type = 'ResourceTemplate'
  resourceTemplate.monitor_template = monitorTemplate
  resourceTemplate.monitor_template_id = monitorTemplate._id
  resourceTemplate.source_model_id = input.source_resource_id
  resourceTemplate.hostgroup = input.hostgroup
  resourceTemplate.hostgroup_id = input.hostgroup._id

  monitorTemplate._type = 'MonitorTemplate'
  monitorTemplate.template_resource = resourceTemplate
  monitorTemplate.template_resource_id = resourceTemplate._id
  monitorTemplate.hostgroup = input.hostgroup
  monitorTemplate.hostgroup_id = input.hostgroup._id

  await monitorTemplate.save()
  await resourceTemplate.save()
  return resourceTemplate
}
